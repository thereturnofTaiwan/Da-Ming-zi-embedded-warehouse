/*
指针是什么？
1、指针是内存中一个最小单元的编号，也就是地址，即我们常说的指针即地址
2、平时口语中说的指针，通常指的是指针变量，是用来存放内存地址的变量
总结：指针就是地址，口语中说的指针通常指的是指针变量
我们可以通过&(取地址操作符)取出变量的内存即地址，把地址放到一个变量中，这个变量就是指针变量
*/
/*#include<stdio.h>
int main()
{
	int a = 10;  //在内存中开辟一块空间
	int* p = &a; //这里我们对变量a,取出它的地址，可以使用&操作符。
	             //a变量为int 类型占用4个字节的空间，这里将a的第一个字节的地址给指针变量p
	printf("%p\n", p);
	return 0;
}
总结：
指针变量，用来存放地址的变量。（存放在指针中的值都被当成地址处理）
那这里的问题是：
一个小的单元到底是多大？（1个字节）
如何编址?
经过仔细的计算和权衡我们发现一个字节对应一个地址是比较合适的。
那么32根地址线产生的地址就会是：
对于32位的机器，假设有32根地址线，那么假设每根地址线在寻址的时候产生高电平（高电压）和低电平（低电压）就是（0或1）；
那么32根地址线产生的地址就会是2的32次方个地址。
每个地址一个字节，那我们就可以给（2^32Byte = 2^32 /1024KB =2^32/1024/1024MB=2^32/1024/1024/1024GB=4GB） 4GB的空间进行寻址。
同样的方法，那64位机器，如果给64根地址线，那能编址多大空间，自己计算。（4*2^32GB=16777216 TB）16777216TB空间进行寻址
这里我们明白：在32位的机器上，地址是32个0或1组成二进制序列，那地址就得用4个字节的空间来存储，所以一个指针的大小就是4个字节
那如果在64位机器上，如果有64个地址线，那一个指针变量的大小为8个字节，才能存放一个地址。
总结：指针是用来存放地址的，地址的唯一标示一块地址空间的。指针的大小在32位平台是4个字节，在64
位平台是8个字节。
*/

/*
指针和指针类型
变量有不同的类型，整形，浮点型等
那指针有没有类型呢，准确的说，是有的。当有这样的代码：
int num =10；
int num = 10;
p = &num;
要将&num (num的地址)保存到P中，我们知道p就是一个指针变量，那它的类型是怎么样的呢？我们给指针变量相应的类型。
char *pc =NULL;
int    *pi  = NULL;
short *ps =NULL;
long *pl  =NULL;
float *pf =NULL;
double *pd ==NULL;
这里可以看到，指针的定义方式是：type+*.
其实：char *类型的指针是为了存放char类型变量的地址。
int *类型的指针是为了存放int 类型变量的地址。那指针类型的意义是什么？下面我们会进行讲解。

*/

/*2.1* 指针 + - 整数
#include<stdio.h>
int main()
{
	int n = 10;
	char* pc = (char*)&n;
	int* pi = &n;

	printf("%p\n", &n);
	printf("%p\n", pc);
	printf("%p\n", pc + 1);
	printf("%p\n", pi);
	printf("%p\n", pi +1);
	return 0;

}
总结：指针的类型决定了指针向前或向后走一步有多大（距离）。
*/

/*
指针的解引用
*/

/*#include<stdio.h>
int main()
{
	int n = 0x11223344;
	char* pc = (char*)&n;
	int* pi = &n;
	*pc = 0;                 //重点在调试的过程中观察内存的变化
	*pi = 0;					 //重点在调试的过程中观察内存的变化
	return 0;
}


指针的类型决定了，对指针解引用的时候有多大的权限（能操作几个字节）
比如：char*的指针解引用就只能访问一个字节，而int*类型指针的解引用就能访问四个字节
*/

/*
野指针
野指针就是指针指向的位置是不可知的（随机的、不正确的、没用明确限制的）

野指针成因
1、指针未初始化

#include<stdio.h>
int main()
{
	int* p;   //局部变量指针未初始化，默认为随机值
	*p = 20;
	return 0;
}

#include<stdio.h>
int main()
{
	int arr[10] = { 0 };
	int* p = arr;
	int i = 0;
	for (i = 0; i <= 11; i++)
	{
			//当指针指向的范围超出数组ARR的范围时， p就是野指针。
		*(p++) = i;
	}
	return 0;
}

3、指针指向的空间释放
*/

/*如何规避野指针
1、指针初始化
2、小心指针越界
3、指针指向空间释放即置NULL
4、避免返回局部变量的地址
5、指针使用之前检查有效性
*/

/*
#include<stdio.h>
int main()
{
	int* p = NULL;
	// .........
	int a = 10;
	p = &a;
	if (p != NULL)
	{
		*p = 20;
	}
	return 0;
}
*/
/*指针运算
指针+-整数
*/

/*#include<stdio.h>
int main()
{
	int x = 0;
	int* p = &x;
	printf("%p\n", p);
	printf("%p\n", p+1);
	char* p2 = (char*)&x;
	printf("%p\n", p2);
	printf("%p\n", p2+1);
	return 0;
}
指针+-整数实际上是跨越指针所指变量类型的字节数乘以我们加的数字，比如在上面的例子中，
我们一开始是将整型指针p进行了+1操作，然后我们对p+1进行以地址形式打印后，
相比原来的p,增加了4个字节，同理，后面的p2是char类型的指针，我们对其进行+1操作后，相比原来的p2的地址
增加了一个字节。



/*

*/
/*
#include<stdio.h>
int main()
{
	int arr[5] = { 1,2,3,4,5 };
	int* p1 = &arr[4];
	int* p2 = &arr[0];
	printf("%d", p1 - p2);
	return 0;
}


#include<stdio.h>
int main()
{
	int arr[5] = { 1,2,3,4,5 };
	int* p1 = &arr[4];
	int* p2 = &arr[0];
	printf("%d", (char*)p1 - (char*)p2);
	return 0;
}
*/

/*
指针的关系运算
既然指针变量中所存储的是地址，地址从本质上来说也只是一串数据，那么也是可以进行比较大小的！
此处不再进行举例给大家进行展示，因为不难理解，但是下面会给大家强调一个要点！
标准规定：
允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，
但是不允许与指向第一个元素之前的那个内存位置的指针进行比较
*/


/*
指针与数组

#include<stdio.h>
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,0 };
	printf("%p\n", arr);
	printf("%p\n", &arr[0]);
	return 0;

}
数组名是和数组首元素的地址一样的
结论： 数组名表示的是数组首元素的地址。   (2种情况除外，数组章节讲解了)
那么这样写是可行的：
int arr[10] = { 1,2,3,4,5,6,7,8,9,0 };
int *p = arr;			p存放的是数组首元素的地址
*/

/*
既然可以把数组名当成地址存放到一个指针中，我们使用指针来访问数组就成为可能
例如

#include<stdio.h>
int main()
{
		int arr[] = { 1,2,3,4,5,6,7,8,9,0 };
		int* p = arr; //指针存放数组首元素的地址
		int sz = sizeof(arr) / sizeof(arr[0]);
		for (int i = 0; i < sz; i++)
		{
			printf("&arr[%d] = %p  <====> p+%d = %p\n", i, &arr[i], i, p + i);
		}
		return 0;
}
所以p + i 其实计算的就是数组arr下标为i的地址
那我们就可以直接通过指针来访问数组
如下

#include<stdio.h>
int main()
{
	int arr[] = { 1,2,3,4,5,6,7,8,9,0 };
	int* p = arr; //指针存放数组首元素的地址
	int sz = sizeof(arr) / sizeof(arr[0]);
	for (int i = 0; i < sz; i++)
	{
			printf("%d" ,*( p + i));
	}
	return 0;
}
*/








